import { UCanvas } from "@/uni_modules/u-canvas";
import { MediaConfig } from './mediaConfig.uts';
import { APIS } from '@/api/config.uts';
import { Ziper } from "@/uni_modules/ns-unzip";
import { request } from '@/utils/http/index';
import { useState }  from '@/store/index.uts'
import i18n from '@/locale'
const defl = uni.getStorageSync('language') as string

export const MediaStoreFolder = `${uni.env.USER_DATA_PATH}/temp/program/mediaStore`;
export class FileManager {
	fs: FileSystemManager;
	token: string;
	programFolder: string;
	userAccount: string;
	
	constructor(){
		const { state } = useState();
		this.fs = uni.getFileSystemManager();
		this.token = state.token;
		this.programFolder = state.programFolder;
		this.userAccount = state.activeUser['account'] as string;
	}
	
	async getProgramList() {
		let results: UTSJSONObject[] = [];
		try {
			const items = this.fs.readdirSync(this.programFolder);
			
			items?.forEach(item => {
				const itemPath = `${this.programFolder}/${item}`;
				this.fs.stat({
					path: itemPath,
					recursive: false,
					success: res => {
						if(!res.stats[0].stats.mIsFile) {
							const data = {
								name: item,
								path: itemPath
							}
							
							results.push(data)
						}
					}
				});
			});
		} catch (err) {
			console.error(err);
		}
		
		return results;
	}
	
	async IsExist(filePath: string) {
		try {
			this.fs.accessSync(filePath);
			return true;
		} catch (err) {
			return false;
		}
	}
	
	async createFolder(folderPath: string) {
		if(!await this.IsExist(folderPath)){
			this.fs.mkdirSync(folderPath, true);
		}	
	}
	
	async deleteProgram(programName: string) {
		const destPath = `${this.programFolder}/${programName}`;
		this.fs.rmdirSync(destPath, true);
	}
	
	async copyFile(srcPath: string, destFilePath: string) {
		this.fs.copyFileSync(srcPath, destFilePath);
		return destFilePath;
	}
	
	async getProgramConfig(programName: string, width: string, height: string) {
		const newProgramFolder = `${this.programFolder}/${programName}`;
		const configFilePath = `${newProgramFolder}/MediaConfig.json`;
		let configFileContent : UTSJSONObject = {}; 
		if (await this.IsExist(configFilePath)) {
			const content = this.fs.readFileSync(configFilePath, 'utf-8') as string;
			configFileContent = JSON.parse(content) as UTSJSONObject;
		} else {
			await this.createFolder(newProgramFolder);
			configFileContent = {
				"Left": 0.0,
				"Top": 0.0,
				"Ratio": 1.0,
				"Program": {
					"name": programName,
					"mediaType": "PROGRAM",
					"resolution": `${width}*${height}`,
					"size": 0,
					"monitorCount": 0,
					"lastUpdatedTime": new Date().toISOString(),
					"createdSource": "admin",
					"status": 0,
					"playCountPerHour": null,
					"isHasValidity": false,
					"validStartDate": null,
					"validEndDate": null,
					"userAccount": this.userAccount,
					"id": 1
				},
			}
			this.fs.writeFileSync(configFilePath, JSON.stringify(configFileContent),"utf-8");
		}
		return new MediaConfig(configFileContent);
	}
	
	async saveProgram(programName: string, data: UTSJSONObject) {
		const programFolder = `${this.programFolder}/${programName}`;
		const configFilePath = `${programFolder}/MediaConfig.json`;
		this.fs.writeFileSync(configFilePath, JSON.stringify(data),"utf-8");
	}
	
	async zipProgram(programName: string) {
		let sourcePath = `${this.programFolder}/${programName}`;
		let packageName = UTSAndroid.getAppContext()?.packageName
		if (sourcePath.startsWith("unifile://")) {
			sourcePath = sourcePath.replace("unifile://usr/", `/storage/emulated/0/Android/data/${packageName}/files`)
		}
		let zipFile = `${this.programFolder}/${programName}.zip`;
		if(await this.IsExist(zipFile)){
			this.fs.unlinkSync(zipFile);
		}
		if (zipFile.startsWith("unifile://")) {
			zipFile = zipFile.replace("unifile://usr/", `/storage/emulated/0/Android/data/${packageName}/files`)
		}
		
		// const result = zipFolder(sourcePath, zipFile);
		// console.log(result);
		// console.log(result);
		// const items = this.fs.readdirSync(`${this.tempDir}/${userAccount}`);
		// console.log(items);
		const ziper = new Ziper({
			zipfilepath: zipFile
		});
		//设置编码，中文出现乱码时使用
		ziper.setCharset("UTF8")
		//其他方法实参同此方法
		ziper.addFolder({
		    "path": sourcePath,
		})
	}	
	
	async readZipFile(programName: string) {
		const destPath = `${this.programFolder}/${programName}.zip`;
		
		if(!await this.IsExist(destPath)){
			await this.zipProgram(programName);
		}
		
		const res = await new Promise<StatSuccessResult>((resolve, reject) => {
			this.fs.stat({
				path: destPath,
				recursive: false,
				success: res => {
					resolve(res)
				},
				fail: res => {
					reject(res)
				}
			});
		})
		
		return res.stats[0].stats.size;
	}
	
	async uploadProgram(programName: string) : Promise<UploadFileSuccess> {
		let zipFile = `${this.programFolder}/${programName}.zip`;
		
		const fileExists = await this.IsExist(zipFile);
		
		if (!fileExists) {
			uni.showToast({
				title: i18n.global.t('program.NeedToZip', null, defl),
				icon: 'none'
			})
			return {
				data: null,
				statusCode: -1;
			}
		}
		
		const rightResult = await new Promise<boolean>((resolve, reject) => {
			if (UTSAndroid.checkSystemPermissionGranted(UTSAndroid.getUniActivity()!, ['android.permission.READ_EXTERNAL_STORAGE'])) {
				resolve(true);
			}else {
				UTSAndroid.requestSystemPermission(
					UTSAndroid.getUniActivity()!, 
					['android.permission.READ_EXTERNAL_STORAGE'],
					(allRight : boolean, _grantedList : Array<string>) => {
						resolve(allRight);
					},
					(doNotAskAgain : boolean, _grantedList: Array<string>) => {
						resolve(false);
						reject(doNotAskAgain);
					},
				)
			}
		})
		
		if (!rightResult) {
			uni.showToast({
				title: i18n.global.t('program.NoRight', null, defl),
				icon: 'none'
			})
			
			return {
				data: null,
				statusCode: -1;
			}
		}		
		
		try {
			uni.showLoading({
				title: i18n.global.t('program.Uploading', null, defl)
			});
			const res = await new Promise<UploadFileSuccess>((resolve, reject) => {
				uni.downloadFile({
					url: "https://qiniu-web-assets.dcloud.net.cn/unidoc/zh/uni-app.png",
				    filePath: `${uni.env.USER_DATA_PATH}/uni-app.png`,
					success: (_res) => {					
						uni.uploadFile({
							url: APIS.uploadZip,
							filePath: zipFile,
							name: 'file',
							header: {
								'Authorization': "Bearer " + this.token
							},
							success(res){
								resolve(res);
							},
							fail(res){
								console.error("fail to upload:", JSON.stringify(res, null, 2));
								reject(res);
							}
						})
					}
				})
			})
			
			uni.hideLoading();
			return res;
		}
		catch (err){
			uni.hideLoading();
			return {
				data: null,
				statusCode: -1;
			}
		}		
	}
	
	async sendProgram(program: UTSJSONObject, snCode: string){
		try {
			uni.showLoading({
				title: i18n.global.t('program.Publishing', null, defl)
			});
			const dataObj = {
				cmd: 'CMD|SendProgram|',
				data: program
				deviceSnCode: snCode
			} as UTSJSONObject
			
			const res = await request("POST", APIS.sendCMD as string, dataObj);
			uni.hideLoading();
			return res as boolean;
		} 
		catch (err){
			console.log('sendCMD program err', err)
			uni.hideLoading();
			return false;
		}
	}
	
	async pushProgram(programData: UTSJSONObject, snCodes: string[]){
		let pushResult = true;
		
		for (const snCode of snCodes) {
			let playRecord = { 
				mediaName: programData.name, 
				mediaType: programData.mediaType, 
				monitorSnCode: snCode, 
				playSuccess: false,
				isTimerPlay: false, 
				nextPlayTime: new Date().toISOString() 
			};
			
			const sendResult = await this.sendProgram(programData, snCode);
			if (sendResult) {
				playRecord.playSuccess = true;
				
				const apiUrl = APIS.playbackRecord.getAll as string;
				const params = "?playSuccess=true&monitorSnCode=" + snCode;
				const result = await request('GET', apiUrl + params, {});
				const playbackRecords = result as Array<UTSJSONObject>;
				if (playbackRecords != null) {
					for (let record of playbackRecords){
						record.playSuccess = false;
						await request('POST', APIS.playbackRecord.save as string, record);
					}
				}
				
				await request('POST', APIS.playbackRecord.save as string, playRecord);
				
				const dataObj = {
					cmd: 'CMD|PlayTime|',
					data: playRecord
					deviceSnCode: snCode
				} as UTSJSONObject
				
				const res = await request("POST", APIS.sendCMD as string, dataObj) as Boolean;
				
				if(!res) {
					const errorM =  `${i18n.global.t("index.Device", null, defl)}：${snCode} ${i18n.global.t("program.SetPlayTimeFailure", null, defl)}`
					uni.showToast({
						icon: 'none',
						title: errorM,
						duration: 3000,
					})
				}
			}
			else {
				uni.showToast({
					icon: 'none',
					title: `${i18n.global.t("index.Device", null, defl)}：${snCode} ${i18n.global.t("program.PublishFailure", null, defl)}`,
					duration: 3000,
					success: () => { 
					}
				})
				
				pushResult = false;
			}
		}
		
		return pushResult;
	}
	
	async capture(programName: string, pageName: string, canvas: UCanvas){
		const thumbnailPath = `${this.programFolder}/${programName}/${pageName}/thumbnail.png`;
		const dataString = canvas.toDataURL();
		const base64Data = dataString.split(',')[1];
		const dataBuffer = uni.base64ToArrayBuffer(base64Data);
		this.fs.writeFileSync(thumbnailPath, dataBuffer,"utf-8");
		return thumbnailPath;
	}
}