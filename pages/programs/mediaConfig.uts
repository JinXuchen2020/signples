import { UCanvas } from "@/uni_modules/u-canvas";
import { DraggableImage } from "./draggableRect.uts";
// import { ProgramFolder} from "./fileManager.uts";
export class MediaConfig {
	left: number;
	top: number;
	ratio: number;
	program: Program;
	pages: MediaPage[];
	
	constructor(data: UTSJSONObject){
		this.left = data.Left as number;
		this.top = data.Top as number;
		this.ratio = data.Ratio as number;
		this.program = new Program(data['Program'] as UTSJSONObject);
		const pages = data['Pages'] as UTSJSONObject[] | null;
		this.pages = pages != null ? pages.map(c=> new MediaPage(c)) : [];
	}
	
	toModel() {
		return {
			Left: this.left,
			Top: this.top,
			Ratio: this.ratio,
			Program: this.program.toModel(),
			Pages: this.pages.map(c=>c.toModel())
		}
	}
}

export class Program {
	name: string;
	mediaType: string;
	resolution: string;
	size: number;
	monitorCount: number;
	lastUpdatedTime: Date;
	createdSource?: string;
	status: number;
	playCountPerHour?: number;
	isHasValidity: boolean;
	validStartDate?: Date;
	validEndDate?: Date;
	userAccount?: string;
	id: number
	
	constructor(data: UTSJSONObject){
		this.name = data['name'] as string;
		this.mediaType = data['mediaType'] as string;
		this.resolution = data['resolution'] as string;
		this.size = data['size'] as number;
		this.monitorCount = data['monitorCount'] as number;
		this.lastUpdatedTime = new Date(data['lastUpdatedTime'] as string);
		this.createdSource = data['createdSource'] as string;
		this.status = data['status'] as number;	
		this.playCountPerHour = data['playCountPerHour'] == null ? null : data['playCountPerHour'] as number;
		this.isHasValidity = data['isHasValidity'] == null ? false : data['isHasValidity'] as boolean;
		this.validStartDate = data['validStartDate'] == null ? null :  new Date(data['validStartDate'] as string);
		this.validEndDate = data['validEndDate'] == null ? null :  new Date(data['validEndDate'] as string);
		this.userAccount = data['userAccount'] as string;
		this.id = data['id'] as number;
	}
	
	toModel() {
		return {
			name: this.name,
			mediaType: this.mediaType,
			resolution: this.resolution,
			size: this.size,
			monitorCount: this.monitorCount,
			lastUpdatedTime: this.lastUpdatedTime.toISOString(),
			createdSource: this.createdSource,
			status: this.status,
			playCountPerHour = this.playCountPerHour;
			isHasValidity = this.isHasValidity;
			validStartDate = this.validStartDate;
			validEndDate = this.validEndDate;
			userAccount: this.userAccount,
			id: this.id
		}
	}
}

export class MediaPage{
	id: number;
	name: string;
	type: string;
	order: number;
	thumbnailFilePath: string;
	isHasValidity: boolean;
	validStartDate?: Date;
	validEndDate?: Date;
	playCount: number;
	playGap?: number;
	adPlayMode?: string;
	schedulers: Scheduler[];
	components: BaseComponent[];
	constructor(data: UTSJSONObject){
		this.id = data.Id as number;
		this.name = data.Name as string;
		this.type = data.Type as string;
		this.order = data.Order as number;
		this.thumbnailFilePath = data['ThumbnailFilePath'] == null ? '' : `${uni.getStorageSync("program-folder") as string}/${data.ThumbnailFilePath}`;
		this.isHasValidity = data.IsHasValidity as boolean;
		this.validStartDate = data['ValidStartDate'] == null ? null :  new Date(data['ValidStartDate'] as string); 
		this.validEndDate =  data['ValidEndDate'] == null ? null :  new Date(data['ValidEndDate'] as string);
		this.playCount = data.PlayCount as number;
		this.playGap = data['PlayGap'] == null ? null : data.PlayGap as number;
		this.adPlayMode = data['AdPlayMode'] == null ? null : data.AdPlayMode as string;		const schedulers = data['Schedulers'] as UTSJSONObject[] | null;
		this.schedulers = schedulers != null ? schedulers.map(c=> new Scheduler(c)) : [];
		this.components = [] as BaseComponent[];		const components = data['Components'] as UTSJSONObject[] | null;
		if(components != null && components.length > 0){
			for(let i = 0; i < components.length; i++){
				const comData = components[i];
				let component : BaseComponent | null = null;
				const type = comData['Type'] as string;
				switch (type) {
					case "Video":
						component = new VideoComponent(comData);
						break;
					case "Text":
						component = new TextComponent(comData);
						break;
					case "Image":
						component = new ImageComponent(comData);
						break;
					case "Web":
						component = new WebComponent(comData);
						break;
					case "Word":
						component = new WordComponent(comData);
						break;
				}
				
				if (component != null) {
					this.components.push(component);
				}
			}
		}
	}	
	
	toModel() {
		return {
			Id: this.id
			Name: this.name,
			Type: this.type,
			Order: this.order,
			ThumbnailFilePath: this.thumbnailFilePath.replace(uni.getStorageSync("program-folder") as string + '/', ''),
			IsHasValidity: this.isHasValidity,
			ValidStartDate: this.validStartDate?.toISOString(),
			ValidEndDate: this.validStartDate?.toISOString(),
			PlayCount: this.playCount,
			PlayGap: this.playGap,
			AdPlayMode: this.adPlayMode,
			Schedulers: this.schedulers.map(c => c.toModel()),
			Components: this.components.map(c => c.toModel()),
		}
	}
	
	async draw(canvas: UCanvas) {
		canvas.cleanGraphic();
		for (const component of this.components.sort((a,b)=>a.zIndex - b.zIndex)){			
			switch (component.type) {
				case "Video":
					const videoComponent = component as VideoComponent;
					await videoComponent.draw(canvas);
					break;
				case "Text":
					const textComponent = component as TextComponent;
					await textComponent.draw(canvas);
					break;
				case "Image":
					const imageComponent = component as ImageComponent;
					await imageComponent.draw(canvas);
					break;
				case "Web":
					const webComponent = component as WebComponent;
					await webComponent.draw(canvas);
					break;
				case "Word":
					const wordComponent = component as WordComponent;
					await wordComponent.draw(canvas);
					break;
			}			
		}
	}
	
	static createInstance(id: number){
		const data = {
			"Id": id ,
			"Name": "页面" + id,
			"Type": "normal",
			"Order": id,
			"ThumbnailFilePath": "",
			"IsHasValidity": false,
			"ValidStartDate": null,
			"ValidEndDate": null,
			"PlayCount": 1,
			"PlayGap": null,
			"AdPlayMode": null,
			"Schedulers": [{
				"Id": 1,
				"StartTime": "00:00:00",
				"EndTime": "23:59:59",
				"ScheduleDays": [1, 2, 3, 4, 5, 6, 7]
			}],
		}
		
		return new MediaPage(data);
	}
}

export class Scheduler {
	id: number;
	startTime: string;
	endTime: string;
	scheduleDays: SchedulerDay[];
	constructor(data: UTSJSONObject){
		this.id = data.Id as number;
		this.startTime = data.StartTime as string;
		this.endTime = data.EndTime as string;
		this.scheduleDays = allDays.map(c=> new SchedulerDay({...c, scheduleDays: data['ScheduleDays'] as number[] }));
	}
	
	toModel() {
		return {
			Id: this.id,
			StartTime : this.startTime,
			EndTime: this.endTime,
			ScheduleDays: this.scheduleDays.map(c=>c.day);
		} as UTSJSONObject
	}
}

export const allDays = [
	{
		label: "一",
		day: 1
	},
	{
		label: "二",
		day: 2
	},
	{
		label: "三",
		day: 3
	},
	{
		label: "四",
		day: 4
	},
	{
		label: "五",
		day: 5
	},
	{
		label: "六",
		day: 6
	},
	{
		label: "日",
		day: 7
	}
]
export class SchedulerDay {
	label: string;
	day: number;
	selected: boolean;
	constructor(data: UTSJSONObject){
		this.label = data.label as string;
		this.day = data.day as number;
		this.selected = (data.scheduleDays as number[]).includes(this.day);
	}
}

export abstract class BaseComponent {
	public id: number;
	public name: string;
	abstract type: string;
	abstract hasFile: boolean;
	public zIndex: number;
	public left: number;
	public top: number;
	public width: number;
	public height: number;
	public source: string;
	public timeLine: number;
	public playCount: number;
	public playDuration: string;
	element?: DraggableImage;
	constructor(data: UTSJSONObject){
		this.id = data.Id as number;
		this.name = data.Name as string;
		this.zIndex = data.ZIndex as number;
		this.left = data['Left'] == null ? 0 : data.Left as number;
		this.top = data['Top'] == null ? 0 : data.Top as number;
		this.width = data['Width'] == null ? 0 : data.Width as number; 
		this.height = data['Height'] == null ? 0 : data.Height as number;
		this.source = data['Source'] == null ? '' : data.Source as string;
		this.timeLine = data['TimeLine'] == null ? 0 : data.TimeLine as number;
		this.playCount = data['PlayCount'] == null ? 1 : data.PlayCount as number;
		this.playDuration = data['PlayDuration'] == null ? "00:00:00" : data.PlayDuration as string;
		this.element = null;
	}
	
	abstract toModel() : UTSJSONObject;
}
export class VideoComponent extends BaseComponent {
	override type: string = "Video";
	override hasFile = true;
	playMode: string;
	isClip: boolean;
	thumbFilePath?: string;
	isShowInfo: boolean;
	constructor(data: UTSJSONObject){
		super(data);
		this.playMode = data['PlayMode'] as string;
		this.isClip = data['IsClip'] == null ? false : data['IsClip'] as boolean;
		this.source = data['Source'] == null ? '' : `${uni.getStorageSync("program-folder") as string}/${data.Source}`;
		this.thumbFilePath = data['ThumbFilePath'] == null ? null : data['ThumbFilePath'] as string;
		this.isShowInfo = this.source.length > 0 ? true : false;
		if (this.thumbFilePath != null) {
			this.element = new DraggableImage(this.left, this.top, this.width, this.height, this.thumbFilePath);
		}
		else {
			this.element = null;
		}
	}
	
	async draw(uCanvas: UCanvas) {
		if (this.thumbFilePath == null && this.element == null) return;
		await this.element!.draw(uCanvas);
	}
	
	override toModel() {
		return {
			Id: this.id,
			Name: this.name,
			Type: this.type,
			ZIndex: this.zIndex,
			Left: this.left,
			Top: this.top,
			Width: this.width,
			Height: this.height,
			Source: this.source.replace(uni.getStorageSync("program-folder") as string + '/', ''),
			Timeline: this.timeLine,
			PlayCount: this.playCount,
			PlayDuration: this.playDuration,
			PlayMode: this.playMode;
			IsClip: this.isClip;
			ThumbFilePath: this.thumbFilePath;
		} as UTSJSONObject
	}
	
	static createInstance(id: number){
		const data = {
			Id: id,
			Name: `视频${id}`,
			ZIndex:  id,
			PlayMode:  "fullscreen",
			PlayCount:  1,
			Timeline:  0,
			PlayDuration: "00:00:00",
		}
		
		return new VideoComponent(data);
	}
}
export class ImageComponent extends BaseComponent {
	override type: string = "Image";
	override hasFile = true;
	effectDuration: number;
	componentEffect: string;
	isShowInfo: boolean;
	constructor(data: UTSJSONObject){
		super(data);
		this.effectDuration = data['EffectDuration'] as number;
		this.componentEffect = data['ComponentEffect'] as string;
		this.source = data['Source'] == null ? '' : `${uni.getStorageSync("program-folder") as string}/${data.Source}`;
		this.isShowInfo = this.source.length > 0 ? true : false;
		if (this.source.length > 0) {
			this.element = new DraggableImage(this.left, this.top, this.width, this.height, this.source);
		}
		else {
			this.element = null;
		}
	}
	
	async draw(uCanvas: UCanvas) {
		if (this.source.length == 0 && this.element == null) return;
		await this.element!.draw(uCanvas);
	}
	
	static createInstance(id: number){
		const data = {
			Id: id,
			Name: `图片${id}`,
			ZIndex:  id,
			PlayCount:  1,
			Timeline:  5,
			PlayDuration: "00:00:05",
			ComponentEffect: "Empty",
			EffectDuration: 1000
		}
		
		return new ImageComponent(data);
	}
	
	override toModel() {
		return {
			Id: this.id,
			Name: this.name,
			Type: this.type,
			ZIndex: this.zIndex,
			Left: this.left,
			Top: this.top,
			Width: this.width,
			Height: this.height,
			Source: this.source.replace(uni.getStorageSync("program-folder") as string + '/', ''),
			Timeline: this.timeLine,
			PlayCount: this.playCount,
			PlayDuration: this.playDuration,
			EffectDuration: this.effectDuration,
			ComponentEffect: this.componentEffect
		} as UTSJSONObject
	}
}

export class TextComponent extends BaseComponent {
	override type: string = "Text";
	override hasFile = false;
	background: string;
	textColor: string;
	playMode: string;
	direction: string;
	effectDuration: number;
	componentEffect: string;
	rollingSpeed: number;
	textSize: number;
	isLoopEnabled: boolean;
	letterSpacing: number;
	lineSpacing: number;
	rtfFilePath?: string;
	verticalContentAlignment: string;
	constructor(data: UTSJSONObject) {
		super(data);
		this.background = data['Background'] as string;
		this.textColor = data['TextColor'] as string;
		this.playMode = data['PlayMode'] as string;
		this.direction = data['Direction'] as string;		
		this.effectDuration = data['EffectDuration'] as number;
		this.componentEffect = data['ComponentEffect'] as string;
		this.rollingSpeed = data['RollingSpeed'] as number;
		this.textSize = data['TextSize'] as number;		
		this.isLoopEnabled = data['IsLoopEnabled'] as boolean;
		this.letterSpacing = data['LetterSpacing'] as number;
		this.lineSpacing = data['LineSpacing'] as number;
		this.rtfFilePath = data['RtfFilePath'] == null ? null : data['RtfFilePath'] as string;
		this.verticalContentAlignment = data['VerticalContentAlignment'] as string;
		this.element = new DraggableImage(this.left, this.top, this.width, this.height, this.source);
	}
	
	async draw(uCanvas: UCanvas) {
		if (this.element == null) return;
		await this.element!.drawText(uCanvas, this);
	}
	
	static createInstance(id: number){
		const data = {
			Id: id,
			Name : `文字${id}`,
			ZIndex : id,
			Type : "Text",
			Width: 256,
			Height: 192,
			Source : "Hello word",
			PlayCount : 1,
			PlayDuration : "00:00:05",
			PlayMode : "pageTurning",
			ComponentEffect : "Empty",
			EffectDuration : 1000,
			Direction : "rollingLeft",
			Timeline : 5,
			Background : "black",
			TextColor : "white",
			TextSize : 16,
			IsLoopEnabled : true,
			LetterSpacing : 2,
			LineSpacing : 2,
			RollingSpeed : 2,
			VerticalContentAlignment: "top",
		}
		
		return new TextComponent(data);
	}
	
	override toModel() {
		return {
			Id: this.id,
			Name: this.name,
			Type: this.type,
			ZIndex: this.zIndex,
			Left: this.left,
			Top: this.top,
			Width: this.width,
			Height: this.height,
			Source: this.source,
			Timeline: this.timeLine,
			PlayCount: this.playCount,
			PlayDuration: this.playDuration,
			Background: this.background,
			TextColor: this.textColor,
			PlayMode: this.playMode,
			Direction: this.direction,
			EffectDuration: this.effectDuration,
			ComponentEffect: this.componentEffect,
			RollingSpeed: this.rollingSpeed,
			TextSize: this.textSize,
			IsLoopEnabled: this.isLoopEnabled,
			LetterSpacing: this.letterSpacing,
			LineSpacing: this.lineSpacing,
			RtfFilePath: this.rtfFilePath,
			VerticalContentAlignment: this.verticalContentAlignment,
		} as UTSJSONObject
	}
}

export class WebComponent extends BaseComponent {
	override type: string = "Web";
	override hasFile = false;
	private imageUrl = "/static/svg/site-web.png";
	constructor(data: UTSJSONObject) {
		super(data);
		this.element = new DraggableImage(this.left, this.top, this.width, this.height, this.imageUrl);
	}
	
	async draw(uCanvas: UCanvas) {
		if (this.element == null) return;
		await this.element!.draw(uCanvas);
	}
	
	static createInstance(id: number){
		const data = {
			Id: id,
			Name: `网页${id}`,
			ZIndex:  id,
			Width: 256,
			Height: 192,
			PlayCount:  1,
			Timeline:  5,
			PlayDuration: "00:00:05",
			Source: "https://www.baidu.com"
		}
		
		return new WebComponent(data);
	}
	
	override toModel() {
		return {
			Id: this.id,
			Name: this.name,
			Type: this.type,
			ZIndex: this.zIndex,
			Left: this.left,
			Top: this.top,
			Width: this.width,
			Height: this.height,
			Source: this.source,
			Timeline: this.timeLine,
			PlayCount: this.playCount,
			PlayDuration: this.playDuration,
		} as UTSJSONObject
	}
}

export class WordComponent extends BaseComponent {
	override type: string = "Word";
	override hasFile = true;
	pageDuration: number;
	isShowInfo: boolean;
	thumbFilePath?: string;
	constructor(data: UTSJSONObject) {
		super(data);
		this.pageDuration = data.PageDuration as number;
		this.isShowInfo = this.source.length > 0 ? true : false;
		this.source = data['Source'] == null ? '' : `${uni.getStorageSync("program-folder") as string}/${data.Source}`;
		this.thumbFilePath = data['ThumbFilePath'] == null ? null : data['ThumbFilePath'] as string;
		if (this.thumbFilePath != null) {
			this.element = new DraggableImage(this.left, this.top, this.width, this.height, this.thumbFilePath);
		}
		else {
			this.element = null;
		}
	}
	
	async draw(uCanvas: UCanvas) {
		if (this.thumbFilePath == null && this.element == null) return;
		await this.element!.draw(uCanvas);
	}
	
	static createInstance(id: number){
		const data = {
			Id: id,
			Name: `文档${id}`,
			ZIndex:  id,
			PlayCount:  1,
			Width: 256,
			Height: 192,
			Timeline:  30,
			PlayDuration: "00:00:30",
			PageDuration: 10,
		}
		
		return new WordComponent(data);
	}
	
	override toModel() {
		return {
			Id: this.id,
			Name: this.name,
			Type: this.type,
			ZIndex: this.zIndex,
			Left: this.left,
			Top: this.top,
			Width: this.width,
			Height: this.height,
			Source: this.source.replace(uni.getStorageSync("program-folder") as string + '/', ''),
			Timeline: this.timeLine,
			PlayCount: this.playCount,
			PlayDuration: this.playDuration,
			PageDuration: this.pageDuration,
			ThumbFilePath: this.thumbFilePath;
		} as UTSJSONObject
	}
}