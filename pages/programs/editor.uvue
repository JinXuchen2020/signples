<template>
	<view class="app">
		<view class="canvas-component">
			<canvas 
				canvas-id="ucanvas" 
				id="ucanvas" 
				class="canvas"
				@touchstart="handleTouchStart"
			    @touchmove="handleTouchMove"
				@touchend="handleTouchEnd"
				:style="'width:'+canvasWidth+'px;height:'+canvasHeight+'px;'" />
		</view>
		<view class="top-button">
			<view class="item">
				<view class="icon-box icon-box-big no-margin" @click="handleSave" >
					<image class="icon" src="/static/svg/save.png" mode="widthFix"></image>
				</view>
			</view>
			<view class="item">
				<view class="icon-box icon-box-big no-margin" @click="handlePush">
					<image class="icon" src="/static/svg/push.png" mode="widthFix"></image>
				</view>
			</view>
			<view class="item">
				<view class="icon-box icon-box-big no-margin" @click="handleReview">
					<image class="icon" src="/static/svg/reviewb.png" mode="widthFix"></image>
				</view>
			</view>
		</view>
		<view class="options">
			<view class="options-tab">				
				<view class="item active" v-if="activeTab == 0" @click="handleActiveTab(0)"><text class="t">组件属性</text></view>
				<view class="item" v-else @click="handleActiveTab(0)"><text class="t">组件属性</text></view>
				<view class="item active" v-if="activeTab == 1" @click="handleActiveTab(1)"><text class="t">页面属性</text></view>
				<view class="item" v-else @click="handleActiveTab(1)"><text class="t">页面属性</text></view>
			</view>
			<view class="option-body">
				<scroll-view class="option-a" :class="{active: activeTab == 0}">
					<VideoForm :item="activeComponent" :medias="mediaList" :program-name="programName" :page-name="activePage?.name" :file-manager="fileManager" @refresh="updateComponent" />
					<ImageForm :item="activeComponent" :medias="mediaList" :program-name="programName" :page-name="activePage?.name" :file-manager="fileManager" @refresh="updateComponent" />
					<WebForm :item="activeComponent" @refresh="updateComponent" />
					<WordForm :item="activeComponent" :program-name="programName" :page-name="activePage?.name" :file-manager="fileManager" @refresh="updateComponent" />
					<TextForm :item="activeComponent" @refresh="updateComponent" />
				</scroll-view>
				<scroll-view class="option-b" :class="{active: activeTab == 1}">
					<PageForm :item="activePage" @refresh="updatePage" />
				</scroll-view>
			</view>
		</view>
		<view class="tools">			
			<view class="pages">
				<swiper id="swiper-view" class="swiper">
					<swiper-item v-if="activeTab == 1" class="swiper-item" item-id="1">
						<view v-for="(item, index) in mediaConfig?.pages" :key="index" class="item" :class="{active: activePage != null && activePage?.name == item.name}" @click="selectPage(item)">
							<text class="t">{{item.name}}</text>
						</view>
						<view class="item" style="background-color: #cccccc;" @click="addPage()">
							<text class="t">+</text>
						</view>
					</swiper-item>
					<swiper-item v-else class="swiper-item" item-id="2">
						<view v-for="(item, index) in  activePage?.components" :key="index" class="item" :class="{active: activeComponent != null && activeComponent?.name == item.name}" @click="selectComponent(item)">
							<text class="t">{{item.name}}</text>
						</view>
					</swiper-item>
				</swiper>
			</view>
			<view class="component">
				<view class="item" @click="createComponent(1)">
					<view class="icon-box no-margin">
						<image class="icon" src="/static/svg/component-6.png" mode="widthFix"></image>
					</view>
					<view class="text">
						<text class="t">视频</text>
					</view>
				</view>
				<view class="item" @click="createComponent(2)">
					<view class="icon-box no-margin">
						<image class="icon" src="/static/svg/component-0.png" mode="widthFix"></image>
					</view>
					<view class="text">
						<text class="t">图片</text>
					</view>
				</view>
				<view class="item" @click="createComponent(3)">
					<view class="icon-box no-margin">
						<image class="icon" src="/static/svg/component-1.png" mode="widthFix"></image>
					</view>
					<view class="text">
						<text class="t">文字</text>
					</view>
				</view>
				<view class="item" @click="createComponent(4)">
					<view class="icon-box no-margin">
						<image class="icon" src="/static/svg/component-7.png" mode="widthFix"></image>
					</view>
					<view class="text">
						<text class="t">网页</text>
					</view>
				</view>
				<view class="item" @click="createComponent(5)">
					<view class="icon-box no-margin">
						<image class="icon" src="/static/svg/component-8.png" mode="widthFix"></image>
					</view>
					<view class="text">
						<text class="t">文档</text>
					</view>
				</view>
			</view>
		</view>
		
		<popup-default
			v-model:visible="pushPopup"
			title="上传发布节目"
			:show-icon="false"
			icon-src="/static/svg/suggest.png"
			@confirm="handlePushProgram"
		>
			<view class="program-meta">
				<view class="uni-flex" style="padding: 6px 0;">
					<text>节目名称: </text>
					<text>{{programName}}</text>
				</view>
				<view class="uni-flex" style="padding: 6px 0;">
					<text>请先选择设备</text>
				</view>
				<checkbox-group class="" @change="devicesChange">
					<checkbox 
						style="margin: 6px 0;"
						v-for="(item, index) in deviceList" 
						:key="index" 
						:value="item.snCode">
							<text :class="{iscs: item['connectStatus'] == 1}">{{item.name}}</text>
					</checkbox>
				</checkbox-group>
			</view>
		</popup-default>
	</view>
</template>
<script lang="uts" setup>
    import {
        UCanvas,
        Composition,
        Text,
        Rectangle,
        Polyline,
        Ring,
        Pie,
        Circle,
        Polygon,
        Picture,
        ImagePixel,
        Point,
    } from "@/uni_modules/u-canvas";
	
	import  { MediaConfig, MediaPage, BaseComponent, VideoComponent, ImageComponent, TextComponent, WebComponent, WordComponent, allDays, Scheduler } from './mediaConfig.uts'
	
	import { routeGoto } from '@/common/router.uts'
	import { FileManager, MediaStoreFolder } from './fileManager.uts'
	import { APIS } from '@/api/config.uts'
	import { request } from '@/utils/http/index'
	
	import VideoForm from './videoForm.uvue'
	import ImageForm from './imageForm.uvue'
	import WebForm from './webForm.uvue'
	import WordForm from './wordForm.uvue'
	import TextForm from './textForm.uvue'
	import PageForm from './pageForm.uvue'
	
	import i18n from '@/locale'
	
	const fileManager = new FileManager();
	
    const uCanvas = new UCanvas({ canvasId: "ucanvas" });
	
	const canvasWidth = ref('256');
	const canvasHeight = ref('192');
	const mediaList = ref<UTSJSONObject[]>([]);
	const deviceList = ref<UTSJSONObject[]>([]);
	const selectedDevices = ref<string[]>([]);
	
	const canvasRect = ref({ left: 0, top: 0, width: 0, height: 0 });
	const programName = ref('');
	const pushPopup = ref(false);
	const mediaConfig = ref<MediaConfig | null>(null);
	
	const activePage = ref<MediaPage | null>(null);
	
	const activeComponent = ref<BaseComponent | null>(null);
	
	const activeTab = ref(1);
	
	const handleActiveTab = (val: number)=>{
		activeTab.value = val
	}
	
	const getCanvasRect = () => {
		uni.createSelectorQuery()
			.in(this)
			.select('.canvas')
			.boundingClientRect(rect => {
				if (rect instanceof NodeInfo) {
					const node = rect as NodeInfo;
					const data = {
						left: node.left,
						top: node.top,
						width: node.width,
						height: node.height
					}
					
					canvasRect.value = data;
				}
			})
			.exec();
	}
	
	const handleIsHasValidityChange = () => {
		if (activePage.value != null) {
			activePage.value!.isHasValidity = !activePage.value!.isHasValidity;
		}
	}
	
	const handleTypeChange = (event: UniRadioGroupChangeEvent) => {
		if (activePage.value != null) {
			activePage.value.type = event.detail.value;
		}
	};
	
	const handleScheduleDayChange = (event: UniCheckboxGroupChangeEvent) => {
		if (activePage.value != null) {
			console.log(event);
			const selectedValues = event.detail.value as string [];
			const scheduler = activePage.value.schedulers[0].toModel();
			const newScheduler = new Scheduler({
				...scheduler,
				ScheduleDays: selectedValues.map(c=> parseInt(c))
			});
			
			activePage.value.schedulers.splice(0, 1, newScheduler);
		}
	}
	
	const addPage = () => {
		const pagesCount = mediaConfig.value!.pages.length + 1;	
		
		const page = MediaPage.createInstance(pagesCount);
		mediaConfig.value!.pages.push(page)
		activePage.value = page;
		activeComponent.value = null;
	}
	
	const updatePage = (newData: UTSJSONObject) => {
		activePage.value = new MediaPage(newData);
	}
	
	const selectPage = async (item: MediaPage) =>{
		if(activePage.value != null) {			
			const thunmbailFilePath = await fileManager.capture(programName.value, activePage.value.name, uCanvas);
			activePage.value!.thumbnailFilePath = thunmbailFilePath;
		}
		activePage.value = item;
		activeComponent.value = null;
	}	
	
	async function drawPage() :Promise<void> {
		await activePage.value?.draw(uCanvas);
	    uCanvas.render();
	}
	
	const handleTouchStart = async (e: TouchEvent) =>{
		if(activePage.value == null) return;
		const touch = e.touches[0];
		const touchX = Math.round(touch.clientX - canvasRect.value["left"] as number);
		const touchY = Math.round(touch.clientY - canvasRect.value["top"] as number);
		// 取消所有选中状态
		for (const component of activePage.value.components.filter(c => c.element != null)) 
		{
			component.element!.isSelected = false;
		}

		// 检测点击的图形
		for (const component of activePage.value.components.filter(c => c.element != null).sort((a,b)=>b.zIndex - a.zIndex)) {
			const image = component.element!;
			if (image.isHitResizeHandle(touchX, touchY)) {
				image.isResizing = true;
				image.isSelected = true;
				activeComponent.value = component;
				break;
			} else if (image.isHit(touchX, touchY)) {
				image.isDragging = true;
				image.isSelected = true;
				activeComponent.value = component;
				break;
			}
		}

		if (activeComponent.value != null) {
			activeComponent.value!.element!.lastTouchX = touchX;
			activeComponent.value!.element!.lastTouchY = touchY;
			await drawPage(); // 立即显示边框
		}
	}
	
	const handleTouchMove = async (e: TouchEvent) => {
		if (activeComponent.value == null || activeComponent.value!.element == null) return;
		
		let component = activeComponent.value;

		const touch = e.touches[0];
		const touchX = Math.round(touch.clientX - canvasRect.value["left"] as number);
		const touchY = Math.round(touch.clientY - canvasRect.value["top"] as number);
		const deltaX = touchX - component.element!.lastTouchX;
		const deltaY = touchY - component.element!.lastTouchY;

		if (component.element!.isDragging) {
			// 拖拽移动
			component.element!.x = Math.max(0, Math.min(
				canvasRect.value["width"] as number - component.element!.width, 
				component.element!.x + deltaX
			));
		    component.element!.y = Math.max(0, Math.min(
				canvasRect.value["height"] as number - component.element!.height, 
				component.element!.y + deltaY
			));
			component.left = component.element!.x;
			component.top = component.element!.y;
		} else if (component.element!.isResizing) {
			// 改变大小
			component.element!.width = Math.min(
				Math.max(10, component.element!.width + deltaX),
				canvasRect.value["width"] as number - component.element!.x
			);
			
			component.element!.height = Math.min(
				Math.max(10, component.element!.height + deltaY),
				canvasRect.value["height"] as number - component.element!.y
			);
			
			component.width = component.element!.width;
			component.height = component.element!.height;
		}

		component.element!.lastTouchX = touchX;
		component.element!.lastTouchY = touchY;
		await drawPage();
	}
	
	    // 触摸结束
	const handleTouchEnd = () => {
		if (activeComponent.value != null && activeComponent.value!.element != null){
			activeComponent.value!.element!.isDragging = false;
			activeComponent.value!.element!.isResizing = false;
			const data = activeComponent.value!.toModel() as UTSJSONObject;
			const type = data['Type'] as string;
			let newComponent : BaseComponent | null = null;
			switch (type) {
				case "Video":
					newComponent = new VideoComponent(data);
					break;
				case "Text":
					newComponent = new TextComponent(data);
					break;
				case "Image":
					newComponent = new ImageComponent(data);
					break;
				case "Web":
					newComponent = new WebComponent(data);
					break;
				case "Word":
					newComponent = new WordComponent(data);
					break;
			}		
			
			activeComponent.value = newComponent;
		}
	}
	
	async function selectComponent(item: BaseComponent){
		activeComponent.value = item;
		if (activeComponent.value!= null && activeComponent.value!.element != null) {
			for (const component of activePage.value!.components.filter(c => c.element != null))
			{
				component.element!.isSelected = false;
			}
			activeComponent.value!.element.isSelected = true;
			await drawPage();
		}
	}
	
	async function createComponent(index: number) {
		if (activePage.value == null) return;
		const maxId = activePage.value!.components.length == 0 ? 0 : Math.max(...activePage.value!.components.map(c => c.id)) + 0;
		let component : BaseComponent | null = null;
		switch(index) {
			case 1:
				component = VideoComponent.createInstance(maxId + 1);
				break;
			case 2:
				component = ImageComponent.createInstance(maxId + 1);
				break;
			case 3:
				component = TextComponent.createInstance(maxId + 1);
				break;
			case 4:
				component = WebComponent.createInstance(maxId + 1);
				break;
			case 5:
				component = WordComponent.createInstance(maxId + 1);
				break;
		}
		if(component !=  null) {
			activePage.value?.components.push(component);
			if (!component.hasFile) {
				selectComponent(component);
			} else {				
				activeComponent.value = component;
			}
		}
	}
	
	async function updateComponent(data: UTSJSONObject) : Promise<void> {
		if (activePage.value == null) return;
		let component : BaseComponent | null = null;
		const type = data['Type'] as string;
		switch (type) {
			case "Video":
				component = new VideoComponent(data);
				break;
			case "Text":
				component = new TextComponent(data);
				break;
			case "Image":
				component = new ImageComponent(data);
				break;
			case "Web":
				component = new WebComponent(data);
				break;
			case "Word":
				component = new WordComponent(data);
				break;
		}
		
		if (component != null) {
			let index = activePage.value!.components.findIndex(c => c.name == data["Name"]);
			activePage.value!.components.splice(index, 1, component!);
			selectComponent(component!);
		}
	}
	
    async function init() : Promise<void> {
		const currentConfig = await fileManager.getProgramConfig(programName.value, canvasWidth.value, canvasHeight.value);
		canvasWidth.value = currentConfig.program.resolution.split("*")[0];
		canvasHeight.value = currentConfig.program.resolution.split("*")[1];
		mediaConfig.value = currentConfig;
		activePage.value = currentConfig.pages.length > 0 ? currentConfig.pages[0] : null;
		activeComponent.value = activePage.value == null || activePage.value!.components.length == 0 ? null : activePage.value?.components[0];
		if (activeComponent.value != null && activeComponent.value!.element != null) {
			activeComponent.value!.element!.isSelected = true;
		}
		await uCanvas.ensureInitialize();
		await drawPage();
    }
	
	async function handleSave() :Promise<void> {
		if(activePage.value == null) return;
		const thunmbailFilePath = await fileManager.capture(programName.value, activePage.value.name, uCanvas);
		activePage.value!.thumbnailFilePath = thunmbailFilePath;
		const data = mediaConfig.value!.toModel();
		await fileManager.saveProgram(programName.value, data);
		uni.showToast({
			icon: 'none',
			title: '保存成功',
			duration: 3000,
			success: () => { 
			}
		})
	}
	
	async function handlePush() :Promise<void> {
		await fileManager.zipProgram(programName.value);
		const size = await fileManager.readZipFile(programName.value);
		mediaConfig.value!.program.size = size;
		pushPopup.value = true;
	}
	
	async function handlePushProgram() : Promise<void> {
		mediaConfig.value!.program.status = 1;
		const programData = mediaConfig.value!.program.toModel();
		
		const uploadResult = await fileManager.uploadProgram(programName.value);
		if (uploadResult.statusCode != 200) {
			uni.showToast({
			  title: '上传失败',
			  icon: 'none',
			  duration: 1000
			})
			return;
		}
		
		const pushResult = await fileManager.pushProgram(programData, selectedDevices.value);
		
		if (pushResult) {
			const data = mediaConfig.value!.toModel();
			await fileManager.saveProgram(programName.value, data);
			uni.showToast({
				icon: 'none',
				title: '发布成功',
				duration: 3000,
				success: () => {
				}
			})
			
			console.log("发布成功");
			pushPopup.value = false;
		}
	}
	
	async function handleReview() :Promise<void> {		
		routeGoto('/pages/programs/review')
	}
	
	async function devicesChange(e: CheckboxGroupChangeEvent) {
		selectedDevices.value = e.detail.value;
	}
	
	async function getMedias(){
		try {
			uni.showLoading({
				title: ''
			});
			const person: UTSJSONObject = {}
			const result = await request('GET', APIS.mediaAll as string, person);
			const d = result as Array<UTSJSONObject>;
			for (let media of d) {
				const param = '?fileName=' + media.src;
				const downloadResult = await new Promise<DownloadFileSuccess>((resolve: (value: DownloadFileSuccess) => void, reject: (reason?: any) => void) => {
					uni.downloadFile({
						url: APIS.mediaDownload as string + param,
						success: (res) => {
							resolve(res);
						},
						fail: (err) => {
							reject(err);
						}
					});
				});
				
				const destPath =  `${MediaStoreFolder}/${media.getString('name')}/${media.src}`;
				const filePath = await fileManager.copyFile(downloadResult.tempFilePath, destPath);
				media.src = filePath;
			}
			mediaList.value = d
			uni.hideLoading();
		} catch (error) {
		  console.error('获取媒体库失败', error)
		  uni.hideLoading();
		}
	}
	
	async function getDevices() {
		try {
			uni.showLoading({
				title: ''
			});
			const activeUser = uni.getStorageSync('userInfo') as UTSJSONObject;
			const person: UTSJSONObject = {}
			const param = activeUser.getString('role') == 'admin' ? `?enabled=1` : `?userAccount={activeUser.account}&eanbled=1`;
			const result = await request('GET', APIS.deviceListPage as string + param, person)
			const d = result as Array<UTSJSONObject>;
			deviceList.value = d
			uni.hideLoading();
		} catch (error) {
		  console.error('获取设备列表失败', error)
		  uni.hideLoading();
		}
	}
	
	onLoad((e: OnLoadOptions): void => {		
		programName.value = e['name'] as string;
		if (e['width'] != null){
			canvasWidth.value = e['width'] as string;
		}
		
		if (e['height'] != null){
			canvasHeight.value = e['height'] as string;
		}
		
		const defl = uni.getStorageSync('language') as string
		
		let defaultLang =  'kr'
		if(defl != ''){
			defaultLang = defl
		}
		
		uni.setNavigationBarTitle({
			title: i18n.global.t('pages.programEditor', null, defaultLang)
		})
	});
    onReady(() => {
        init();
		getCanvasRect();
		getMedias();
		getDevices();
    });
</script>

<style lang="scss">
    .canvas-component {
        width: 100%;
		display: flex;
		align-items: center;
		justify-content: center;
		padding: 60px 20px 20px 20px;
		
		.canvas {
		    width: 100%;
		    height: 100%;
			background: #f0f0f0;
		}
    }
	.tools{
		position: fixed;
		width: 100%;
		left: 0;
		bottom: 0;
		z-index: 999;
		background-color: $uni-bg-color;
		padding: 24rpx;
		
		.pages{
			padding: 0 0 24rpx 0;
			.swiper-item{
				flex-direction: row;
				align-items: center;
				justify-content: space-between;
				width: 100%;
				.item{
					// width: 21%;
					height: 48rpx;
					flex: 1;
					background-color: #000000;
					flex-direction: row;
					align-items: center;
					justify-content: center;
					border-radius: $uni-border-radius-lg;
					margin: 0 1%;
					.t{
						color: $uni-text-color-inverse;
						font-size: $uni-font-size-sm;
					}
				}
				.item.active{
					background-color: $uni-bg-color-blue;
				}
			}
		}
		
		.component{
			padding: 0 0 24rpx 0;
			flex-direction: row;
			align-items: center;
			justify-content: space-between;
			.item{
				.icon-box{
					margin: 0 auto;
				}
				.t{
					font-size: $uni-font-size-sm;
				}
			}
		}
	}
    .top-button{
		padding: 24rpx 0;
		flex-direction: row;
		align-items: center;
		justify-content: space-between;
		position: fixed;
		right: 0;
		top: 0;
		.item{
			.icon-box{
				margin: 0 12rpx;
				.icon{
					background: #ffffff;
					border-radius: 128rpx;
					padding: 8rpx;
					border: 1px solid #eeeeee;
				}
			}
			.t{
				font-size: $uni-font-size-sm;
			}
		}
	}
	.options{
		padding: 24rpx;
		
		.options-tab{
			width: 100%;
			display: flex;
			flex-direction: row;
			align-items: center;
			justify-content: center;
			padding-bottom: 24rpx;
			
			.item{
				padding: 0 24rpx;
				.t{
					font-size: 14px;
				}
			}
			.item.active{
				.t{
					color: $uni-color-primary
				}
			}
		}
		.option-body {
			.option-a,
			.option-b {
				display: none;
			}
			.option-a.active,
			.option-b.active {
				display: flex;
				height: 700rpx;
			}
		}
	}
	.program-meta{
		.item{
			padding: 24rpx 0;
			.item-title {
				.t {
					color: $uni-text-color-grey;
				}
			}
			.item-body{
				padding-top: 24rpx;
				.program-size{
					flex-direction: row;
					align-items: center;
					justify-content: space-between;
					.input-box{
						width: 45%;
						.uni-input{
							background-color: $uni-bg-color-grey;
							border-radius: $uni-border-radius-lg;
							font-size: $uni-font-size-lg;
							padding: 24rpx 32rpx;
						}
					}
					
				}
				.program-layout{
					flex-direction: row;
					align-items: center;
					justify-content: space-between;
					.layout{
						flex-direction: row;
						align-items: center;
						justify-content: center;
						padding: 8rpx;
					}
					.layout.checked{
						background-color: $uni-bg-color-light-blue;
						border-radius: $uni-border-radius-lg;
					}
				}
			}
		}
	}
	.iscs{
		color: #00b61f;
	}
</style>