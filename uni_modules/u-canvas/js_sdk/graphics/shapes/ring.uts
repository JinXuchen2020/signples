import { Offset, Point } from "../../coords";
import { Graphic } from "./graphic";
import { RingOptions } from "./options";
import { Canvas, Path } from "../../renderer";
import { Aabb } from "../aabb";
import { toGraphicOptions } from "../utils";

export class Ring extends Graphic {
	public override readonly type = "Ring";

	/**
	 * 中心点 x 坐标
	 */
	public cx : number;

	/**
	 * 中心点 y 坐标
	 */
	public cy : number;

	/**
	 * 内半径
	 */
	public innerRadius : number;

	/**
	 * 外半径
	 */
	public outerRadius : number;

	/**
	 * 起始弧度
	 */
	public startAngle : number;

	/**
	 * 结束弧度
	 */
	public endAngle : number;

	/**
	 * 绘制方向, true 逆时针, false 顺时针. 默认false
	 */
	public counterclockwise : boolean;

	public constructor(options : RingOptions) {
		super(toGraphicOptions(options));

		this.cx = options.cx;
		this.cy = options.cy;
		this.innerRadius = options.innerRadius;
		this.outerRadius = options.outerRadius;
		this.startAngle = options.startAngle;
		this.endAngle = options.endAngle;
		this.counterclockwise = options.counterclockwise ?? false;
	}

	public override getAabb() : Aabb {
		const { x, y } = this.matrix.apply(new Point(0, 0));
		const aabb = Aabb.zero()
			.offseted(new Offset(x, y))
			.grew(new Offset(this.outerRadius * 2, this.outerRadius * 2));

		return aabb;
	}

	public override paint(canvas : Canvas, offset : Offset) : void {
		super.paint(canvas, offset);
		const { x: cx, y: cy } = this.toGlobalPoint(new Point(this.cx, this.cy));
		const { innerRadius, outerRadius, startAngle, endAngle, counterclockwise, style } = this;
		const path = new Path();

		path.arc(cx, cy, outerRadius, startAngle, endAngle, counterclockwise);
		path.arc(cx, cy, innerRadius, endAngle, startAngle, !counterclockwise);
		path.closePath();

		canvas.drawPath(path, style);
	}

	public override hitTest(point : Point) : this | null | undefined {
		const { innerRadius, outerRadius, startAngle, endAngle } = this;
		const { x: dx, y: dy } = point.subtracted(this.toGlobalPoint(new Point(this.cx, this.cy)));
		const distance = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));

		if (distance >= innerRadius && distance <= outerRadius) {
			let angle = Math.atan2(dy, dx);
			// Adjust the angle to be between 0 and 2π
			if (angle < 0) angle += 2 * Math.PI;
			if (angle >= startAngle && angle <= endAngle) return this;
		}

		return null;
	}
}